
```{r}
# Importation des données
panel_data <- load_parquet("panel_data.parquet")
wide_panel_data <- load_parquet("wide_panel_data.parquet")
mca_data <- load_parquet("mca_data.parquet")
detailed_mca_data <- load_parquet("detailed_mca_data.parquet")
map_data <- load_shapefile("FRANCE.shx")

codes_regions <- fread("data_other/codes_regions_Insee.csv", header = TRUE)
codes_regions$ABRV <- sapply(codes_regions$LIBELLE, get_first_letters)
```

```{r}
# Définition des variables

## Outcomes
relative_outcomes <- c("part_T1", "part_T2", "GD_ratio_T1", "GD_ratio_T2", "EC_ratio_T1", "EC_ratio_T2")
absolute_outcomes <- c("part_T1", "part_T2", "GIns_ratio_T1", "DIns_ratio_T1", "GIns_ratio_T2", "DIns_ratio_T2", "EIns_ratio_T1", "CIns_ratio_T1", "EIns_ratio_T2", "CIns_ratio_T2")
### Pour l'ACP, on considère l'absence de candidat de gauche au second tour en 2017.
mca_relative_outcomes <- relative_outcomes[relative_outcomes != "GD_ratio_T2"]
mca_absolute_outcomes <- absolute_outcomes[absolute_outcomes != "GIns_ratio_T2"]
mca_detailed_outcomes <- grep("^pvoix", names(detailed_mca_data), value = TRUE)

## Régresseurs
panel_regressors <- c("ppropri", "popcomm", "popagglo", "pinscript", "age", "prop1539", "prop4059", "prop60p", "propf", "propbac", "propsup", "pagri", "pindp", "pcadr", "ppint", "pempl", "pchom", "petranger")
### Régresseurs abandonnés pour éviter la colinéarité : prop014, propnodip, pouvr
### Ainsi que revmoy en attendant de compléter la série
mca_regressors <- c("ppropri", "popcomm", "popagglo", "pinscript", "age", "prop1539", "prop4059", "prop60p", "propf", "propbac", "propsup", "pagri", "pindp", "pcadr", "ppint", "pempl", "pchom", "petranger", "revmoy", "pcrimesdelits", "mmoyfortune", "pisf", "prsa", "type_comm")
### Régresseurs abandonnés pour complaire aux économètres : prefract1791, pclerge1791, pclerge1856, pmessalisants1950
```

```{r}
# Fonction permettant de générer des cartes statiques

## Elle comporte 5 paramètres :
### year
### region permet de restreindre la carte à une région
#### La fonction utilise les codes listés dans data_other/code_regions_Insee.csv
#### La valeur 0 correspond à la France entière.
### mapped_var est le code de la variable à représenter
### mapped_var_name est le nom à afficher dans la légende
### base_width est un paramètre de résolution, de préférence >7 pour une région et >15 pour la France

## Les cartes sont sauvegardées dans le répertoire output, leur nom est généré automatiquement.
## Elles sont aussi affichées ici.
## Pour la France entière, cela prend du temps !

draw_map <- function(input_year, region, mapped_var, mapped_var_name, base_width) {
  # Chargement des données
  carto <- subset(panel_data, year == input_year)
  carto <- merge(map_data, carto, by.x = "INSEE_COM", by.y = "codecommune", all.x = TRUE)
  if (region != 0) {
    carto <- subset(carto, INSEE_REG == region)
    reg_name <- codes_regions$LIBELLE[codes_regions$REG == region]
    reg_abrv <- codes_regions$ABRV[codes_regions$REG == region]
  } else {
    reg_name <- "France"
    reg_abrv <- "FR"
  }

  # Création des chemins
  title <- paste0(mapped_var_name, "\nPremier tour des élections présidentielles\n", reg_name, ", ", input_year)
  output_file <- paste0("output/", mapped_var, "_", input_year, "_", reg_abrv, ".png")
  
  # Exportation d'une carte en haute résolution
  ## Calcul des dimensions
  bbox <- st_bbox(carto)
  aspect_ratio <- diff(c(bbox$xmin, bbox$xmax)) / diff(c(bbox$ymin, bbox$ymax))
  base_height <- base_width / aspect_ratio
  font_size <- base_width * 2.2
  ## Création et enregistrement
  plot_png <- ggplot() +
    geom_sf(data = carto, aes(fill = .data[[mapped_var]])) +
    scale_fill_viridis_c(name = mapped_var_name, labels = scales::percent_format(scale = 1)) +
    ggtitle(paste(title)) +
    theme_minimal() +
    theme(plot.title = element_text(hjust = 0.5, size = font_size),
          axis.text = element_blank(),
          panel.grid = element_blank(),
          plot.title.position = "plot",
          legend.title = element_text(size = font_size * 0.8),
          legend.text = element_text(size = font_size * 0.7))
  ggsave(output_file, plot = plot_png, width = base_width, height = base_height, units = "in")
  
  # Affichage d'une carte en résolution normale
  display_plot <- ggplot() +
    geom_sf(data = carto, aes(fill = .data[[mapped_var]])) +
    scale_fill_viridis_c(name = mapped_var_name, labels = scales::percent_format(scale = 1)) +
    ggtitle(paste(title)) +
    theme_minimal() +
    theme(plot.title = element_text(hjust = 0.5),
          axis.text = element_blank(),
          panel.grid = element_blank(),
          plot.title.position = "plot",
          legend.title = element_text(),
          legend.text = element_text())   
    print(display_plot)
}
```

# Panel

## Analyse des valeurs manquantes

Tableau présentant la proportion de NA par régresseur et par an, *à colorer façon heatmap ?*

```{r}
count_na <- function(x) mean(is.na(x)) * 100

na_prop_table <- data.table(year = unique(panel_data$year))

for (regressor in panel_regressors) {
  na_prop <- panel_data[, .(na_prop = count_na(get(regressor))), by = year]
  na_prop_table <- merge(na_prop_table, na_prop, by = "year", all.x = TRUE)
  setnames(na_prop_table, "na_prop", regressor)
}

na_prop_table[] <- lapply(na_prop_table, round_and_remove_zeros)
print(na_prop_table)

rm(count_na, na_prop, na_prop_table, regressor)
```

## Analyses descriptives

Evolution historique des principaux outcomes et du taux de propriétaires.

Il faudra vérifier pourquoi on n'obtient pas les mêmes chiffres avec ppropri et npropri/nlogements. Car le graph de ppropri est calculé par la moyenne sur les communes, plutôt que la moyenne pondérée par la population ?

```{r}
# Exemple grossier avec le taux de propriétaires
ppropri <- aggregate(ppropri ~ year, data = panel_data, FUN = mean)
ggplot(ppropri, aes(x = year, y = ppropri)) +
  geom_line() +
  geom_point() +
  labs(x = "Année", y = "%", title = "Taux de propriétaires de leur résidence principale, 1965-2022")
rm(ppropri)
```

```{r}
# Calcul du taux agrégé de propriétaires
propri <- load_parquet("Proprietaires/proprietairescommunes.parquet")

propri_tot <- data.table(year = numeric(), sum_npropri = numeric(), sum_nlogement = numeric(), prop_ratio = numeric())
for (year in 1960:2022) {
  col_npropri <- paste0("npropri", year)
  col_nlogement <- paste0("nlogement", year)
  sum_npropri <- sum(propri[[col_npropri]], na.rm = TRUE)
  sum_nlogement <- sum(propri[[col_nlogement]], na.rm = TRUE)
  prop_ratio <- sum_npropri / sum_nlogement
  propri_tot <- rbind(propri_tot, data.table(year = year, sum_npropri = sum_npropri, sum_nlogement = sum_nlogement, prop_ratio = prop_ratio))
}

# Graph
plot <- ggplot(propri_tot, aes(x = year, y = prop_ratio)) +
  geom_line(color = "skyblue") +
  geom_point(color = "skyblue") +
  labs(title = "Proportion de propriétaires, 1960-2022",
       x = "Année",
       y = "Proportion de propriétaires") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5))

print(plot)
ggsave("output/ppropri_1960_2022.png", plot, width = 8, height = 6, dpi = 300)

# Nettoyage
rm(col_npropri, col_nlogement, propri, sum_npropri, sum_nlogement, prop_ratio, propri_tot, year, plot)
```

Cartes...

```{r}
draw_map(1988, 94, "ppropri", "Taux de propriétaires", 8)
```

## Panel...

```{r include=FALSE}
# On convertit les données aux format pdata et on sélectionne les régresseurs
panel_as_pdata <- pdata.frame(panel_data, index = c("codecommune", "year"))

# On ajuste le modèle pour les ratios relatifs = sur exprimés
## Possibilité d'utiliser within comme paramètre et d'éliminer le clustering.
relative_results <- list()
for (outcome in relative_outcomes) {
  regression_formula <- as.formula(paste(outcome, "~", paste(panel_regressors, collapse = "+")))
  model_name <- paste0(outcome, "_model")
  relative_results[[model_name]] <- plm(regression_formula, data = panel_as_pdata, model = "fd", cluster = "dep", vcov = "HC1")
}
suppressWarnings(
  stargazer(relative_results, type = "html", out = "output/panel_relative_results.html")
)

# On ajuste le modèle pour les ratios relatifs = sur inscrits
absolute_results <- list()
for (outcome in absolute_outcomes) {
  regression_formula <- as.formula(paste(outcome, "~", paste(panel_regressors, collapse = "+")))
  model_name <- paste0(outcome, "_model")
  absolute_results[[model_name]] <- plm(regression_formula, data = panel_as_pdata, model = "fd", cluster = "dep")
}
suppressWarnings(
  stargazer(absolute_results, type = "html", out = "output/panel_absolute_results.html")
)

rm(absolute_results, model_name, regression_formula, relative_results, outcome, panel_as_pdata)

# Fusionner les ratios pour chaque tour ?
```

# ACP

## Analyses descriptives

Tableau récapitulatif (dont valeurs manquantes)

```{r}
nb_communes <- uniqueN(mca_data, by = "codecommune")

# Initialisation et calcul des valeurs
stat_desc <- data.table()
for (col in names(mca_data)) {if (!(col %in% c("dep", "codecommune", "codecommune2", "year", "GD_ratio_T2", "GIns_ratio_T2"))) {
  summary <- mca_data[, {
    fivenum_values <- fivenum(get(col))
    nan_count <- sum(is.na(get(col)))
    nan_count_prop <- round(100 * nan_count / nb_communes, 2)
    nan_pop <- sum(popcomm[is.na(get(col))], na.rm = TRUE)
    data.table(
      Variable = col,
      "Min" = round(fivenum_values[1], 0),
      "1er quartile" = fivenum_values[2],
      "Mediane" = fivenum_values[3],
      "3e quartile" = fivenum_values[4],
      "Max" = fivenum_values[5],
      "Valeurs manquantes" = nan_count,
      "En % des communes" = nan_count_prop
    )
  }]
stat_desc <- rbind(stat_desc, summary)
}}

# Simplification des valeurs et enregistrement du tableau
stat_desc[] <- lapply(stat_desc, round_and_remove_zeros)
print(xtable(stat_desc, type = "latex"), file = "output/stat_desc_acm.tex")
print(stat_desc)

# Nettoyage
rm(col, nb_communes, stat_desc, summary)
```

Corrélogramme

```{r include=FALSE}
corr_variables <- c(mca_regressors, mca_relative_outcomes)
mca_corr_data <- mca_data[, ..corr_variables, with = FALSE]

mca_corr_data <- mca_corr_data[, .SD, .SDcols = sapply(mca_corr_data, is.numeric)]
mca_corr_data <- mca_corr_data[complete.cases(mca_corr_data)]

correlation_matrix <- cor(mca_corr_data)

png(filename = "output/corrplot.png", width = 2200, height = 1800)
corrplot(
  correlation_matrix,
  type = "upper",
  method = "color",
  order = "FPC",
  tl.cex = 3.5,
  tl.srt = 60,
  tl.col = "darkgrey",
  cl.cex = 3.5
)
dev.off()

rm(corr_variables, correlation_matrix, mca_corr_data)
```

Cartes ?

## **Régression**

Pour comparer avec les coefficients obtenus sur les données de panel.
Les se sont calculées avec clustering départemental, mais cela ne semble pas les affecter.

```{r include=FALSE}
# Pour traiter le type de commune comme une variable catégorielle. Pour mémoire :
## 1 = villages (agglos <2000 hab)
## 2 = bourgs (agglos >2000 et <100 000 hab)
## 3 = banlieues (communes secondaires agglos >100 000 hab)
## 4 = métropoles (communes principales agglos >100 000 hab)
mca_data$type_comm <- factor(mca_data$type_comm)

relative_results <- list()
for (outcome in mca_relative_outcomes) {
  regression_formula <- as.formula(paste(outcome, "~", paste(mca_regressors, collapse = "+")))
  model_name <- paste0(outcome, "_model")
  relative_results[[model_name]] <- lm.cluster(regression_formula, data = mca_data, cluster = "dep")
}
suppressWarnings(
  stargazer(relative_results, type = "html", out = "output/2017_relative_results.html")
)

relative_results <- list()
for (outcome in mca_absolute_outcomes) {
  regression_formula <- as.formula(paste(outcome, "~", paste(mca_regressors, collapse = "+")))
  model_name <- paste0(outcome, "_model")
  relative_results[[model_name]] <- lm.cluster(regression_formula, data = mca_data, cluster = "dep")
}
suppressWarnings(
  stargazer(relative_results, type = "html", out = "output/2017_absolute_results.html")
)

rm(model_name, outcome, regression_formula)
```

## ACP

```{r}
# Sélection des variables
## On ajoute les modalités éliminées pour éviter la colinéarité dans les régressions.
## On supprime les valeurs manquantes.
variables_of_interest <- c(mca_regressors, "prop014", "propnodip", "pouvr", mca_detailed_outcomes)
mca_data_subset <- detailed_mca_data[, ..variables_of_interest]
mca_data_subset <- na.omit(mca_data_subset)

# On normalise les variables numériques
mca_data_subset[, names(mca_data_subset)[sapply(mca_data_subset, is.numeric)] := lapply(.SD, scale), .SDcols = names(mca_data_subset)]

# Création d'indicatrices pour les types de communes
mca_data_subset$type_comm <- as.factor(mca_data_subset$type_comm)
dummies <- model.matrix(~ type_comm - 1, data = mca_data_subset)
colnames(dummies) <- paste("type_comm", levels(mca_data_subset$type_comm), sep = "_")
mca_data_subset <- cbind(mca_data_subset, dummies)
mca_data_subset$type_comm <- NULL

# Analyse
result <- PCA(mca_data_subset, graph = TRUE)
fviz_screeplot(result, addlabels = TRUE, ylim = c(0, 50))
print(result$var$contrib)

# Nettoyage
rm(dummies, mca_data_subset, result, variables_of_interest)
```
