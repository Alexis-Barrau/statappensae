Travail en cours pour traiter l'ensemble des élections présidentielles.

On construit la base en itérant à partir des résultats électoraux. On commence par créer une table de destination, intégrant l'ensemble des variables souhaitées. Puis pour chaque fichier électoral...

1.  On recode les outcomes, à l'aide des informations sur les orientations politiques des candidats stockées dans une table dédiée.

2.  On ajoute les contrôles de l'année correspondante.

3.  On fusionne avec la table de destination (rbind pour s'ajouter aux données existantes).

```{r}
# Chargement des données sur les orientations politiques des candidats
candidats <- fread("data_other/candidats.csv", header = TRUE)

# Chargement et préparation des contrôles
propri <- load_parquet("Proprietaires/proprietairescommunes.parquet")
popul <- load_parquet("Taille_agglo_commune/popcommunes.parquet")
ages <- load_parquet("Age_csp/agesexcommunes.parquet")
catsociopro <- load_parquet("CSP/cspcommunes.parquet")
nation <- load_parquet("Nationalites/etrangerscommunes.parquet")
reven <- load_parquet("Revenus/revcommunes.parquet")
diplo <- load_parquet("Diplomes/diplomescommunes.parquet")
crim <- load_parquet("CSP/crimesdelitscommunes.parquet")
rsa <- load_parquet("CSP/rsacommunes.parquet")

## Conversion du nombre de (non-)diplômés en proportion
for (year in unique(candidats$Annee)) {
  suffixes <- c("pop", "propnodip", "propbac", "propsup", "nodip", "bac", "sup")
  for (i in seq_along(suffixes)) {assign(paste0("var_name_", i), paste0(suffixes[i], year))}
  diplo[popul, c(var_name_1) := .(get(var_name_1)), on = "codecommune"]
  diplo[, (var_name_2) := get(var_name_5)/get(var_name_1)]
  diplo[, (var_name_3) := get(var_name_6)/get(var_name_1)]
  diplo[, (var_name_4) := get(var_name_7)/get(var_name_1)]
}

## Correction des codes communes dans la base RSA (traités comme des nombres donc avec suppression des zéros initiaux)
rsa$codecommune <- as.character(rsa$codecommune)
rsa$codecommune <- ifelse(nchar(rsa$dep) == 1, paste0("0", rsa$codecommune), rsa$codecommune)

# religcomm <- load_parquet("Enseignement_prive/religiositecommunes.parquet")
# religdep <- load_parquet("Enseignement_prive/religiositedepartements.parquet")

## Ratio de nclerge1791 sur le nombre d'habitants, pour avoir une idée de la présence des institutions religieuses dans la commune
# religcomm[popul, c("pop1791") := .(i.pop1791), on = "codecommune"]
# religcomm[, pclerge1791 := nclerge1791/pop1791]
# religcomm[, pclerge1791 := replace(pclerge1791, is.infinite(pclerge1791), NA)]
```

```{r}
# Création de la base finale
full_data <- data.table(
  dep = character(),
  codecommune = character(),
  year = integer(),
  inscrits = numeric(), 
  # on l'utilisera après fusion avec la population pour calculer le taux d'inscrits
  # si cette information n'est pas déjà estimée par les auteurs
  part_T1 = numeric(),
  part_T2 = numeric(),
  GD_ratio_T1 = numeric(),
  GD_ratio_T2 = numeric(),
  GIns_ratio_T1 = numeric(),
  DIns_ratio_T1 = numeric(),
  GIns_ratio_T2 = numeric(),
  DIns_ratio_T2 = numeric(),
  EC_ratio_T1 = numeric(),
  EC_ratio_T2 = numeric(),
  EIns_ratio_T1 = numeric(),
  CIns_ratio_T1 = numeric(),
  EIns_ratio_T2 = numeric(),
  CIns_ratio_T2 = numeric(),  
  ppropri = numeric(),
  popcomm = numeric(),
  popagglo = numeric (),
  age = numeric (),
  prop014 = numeric (),
  prop1539 = numeric (),
  prop4059 = numeric (),
  prop60p = numeric (),
  propf = numeric(),
  propnodip = numeric (),
  propbac = numeric (),
  propsup = numeric (),
  pagri = numeric (),
  pindp = numeric (),
  pcadr = numeric (),
  ppint = numeric (),
  pempl = numeric (),
  pouvr = numeric (),
  pchom = numeric (),
  petranger = numeric(),
  revmoy = numeric(),
  pcrimesdelits = numeric(),
  prsa = numeric ()
  )
```

```{r}
# Recodages politiques + contrôles + merge
recode_merge_pres <- function(input_year) {
  tablename <- paste0("pres", input_year)
  dt <- get(tablename)
# Ajout des années lorsqu'elles manquent dans la table d'origine
  if (year %in% colnames(dt)) {dt[is.na(dt$year), year := input_year]}
  else {dt[, year := input_year]}

# Outcomes
## Participation
  dt[, part_T1 := votants/inscrits]
  dt[, part_T2 := votantsT2/inscritsT2]
## Droite / gauche
### Identification des candidats
  T1maskG <- candidats[Annee == input_year & DrGau == "G", .(variable = paste0("voix", Candidat))]
  T1maskD <- candidats[Annee == input_year & DrGau == "D", .(variable = paste0("voix", Candidat))]
  T2maskG <- candidats[Annee == input_year & DrGau == "G", .(variable = paste0("voixT2", Candidat))]
  T2candidateG <- intersect(T2maskG$variable, names(dt))
  T2maskD <- candidats[Annee == input_year & DrGau == "D", .(variable = paste0("voixT2", Candidat))]
  T2candidateD <- intersect(T2maskD$variable, names(dt))
### Ratio relatif / sur l'orientation politique opposée
  dt[, GD_ratio_T1 := rowSums(.SD, na.rm = TRUE) / exprimes, .SDcols = T1maskG$variable]
  dt[is.infinite(GD_ratio_T1), GD_ratio_T1 := 1]
  # Pour le second tour, le ratio G/exp est seulement calculé si un candidat de gauche est présent.
  if (length(T2candidateG) == 1) {
    dt[, GD_ratio_T2 := rowSums(.SD, na.rm = TRUE) / exprimesT2, .SDcols = T2candidateG]
    dt[is.infinite(GD_ratio_T2), GD_ratio_T2 := 1]
    }
  else {dt[, GD_ratio_T2 := NA]}
### Ratios absolus / sur les inscrits
  dt[, GIns_ratio_T1 := rowSums(.SD, na.rm = TRUE) / inscrits, .SDcols = T1maskG$variable]
  dt[is.infinite(GIns_ratio_T1), GIns_ratio_T1 := 1]
  dt[, DIns_ratio_T1 := rowSums(.SD, na.rm = TRUE) / inscrits, .SDcols = T1maskD$variable]
  dt[is.infinite(DIns_ratio_T1), DIns_ratio_T1 := 1]
  # Pour le second tour, le ratio de chaque orientation est seulement calculé si un candidat est présent. 
  if (length(T2candidateG) >= 1) {
    dt[, GIns_ratio_T2 := rowSums(.SD, na.rm = TRUE) / inscritsT2, .SDcols = T2candidateG]
    dt[is.infinite(GIns_ratio_T2), GIns_ratio_T2 := 1]
    } 
  else {dt[, GIns_ratio_T2 := NA]}
  if (length(T2candidateD) >= 1) {
    dt[, DIns_ratio_T2 := rowSums(.SD, na.rm = TRUE) / inscritsT2, .SDcols = T2candidateD]
    dt[is.infinite(DIns_ratio_T2), DIns_ratio_T2 := 1]
    } 
  else {dt[, DIns_ratio_T2 := NA]}
## Centre / extrêmes
### Identification des candidats
  T1maskC <- candidats[Annee == input_year & CentExt == "C", .(variable = paste0("voix", Candidat))]
  T1maskE <- candidats[Annee == input_year & CentExt == "E", .(variable = paste0("voix", Candidat))]
  T2maskC <- candidats[Annee == input_year & CentExt == "C", .(variable = paste0("voixT2", Candidat))]
  T2candidateC <- intersect(T2maskC$variable, names(dt))
  T2maskE <- candidats[Annee == input_year & CentExt == "E", .(variable = paste0("voixT2", Candidat))]
  T2candidateE <- intersect(T2maskE$variable, names(dt))
### Ratio relatif / sur l'orientation politique opposée
  dt[, EC_ratio_T1 := rowSums(.SD, na.rm = TRUE) / exprimes, .SDcols = T1maskE$variable]
  dt[is.infinite(EC_ratio_T1), EC_ratio_T1 := 1]
  # Pour le second tour, le ratio E/exp est seulement calculé si un candidat des extrêmes est présent.
  if (length(T2candidateE) == 1) {
    dt[, EC_ratio_T2 := rowSums(.SD, na.rm = TRUE) / exprimesT2, .SDcols = T2candidateE]
    dt[is.infinite(EC_ratio_T2), EC_ratio_T2 := 1]
    }
  else {dt[, EC_ratio_T2 := NA]}
### Ratios absolus / sur les inscrits
  dt[, CIns_ratio_T1 := rowSums(.SD, na.rm = TRUE) / inscrits, .SDcols = T1maskC$variable]
  dt[is.infinite(CIns_ratio_T1), CIns_ratio_T1 := 1]
  dt[, EIns_ratio_T1 := rowSums(.SD, na.rm = TRUE) / inscrits, .SDcols = T1maskE$variable]
  dt[is.infinite(EIns_ratio_T1), EIns_ratio_T1 := 1]
  # Pour le second tour, le ratio de chaque orientation est seulement calculé si un candidat est présent. 
  if (length(T2candidateC) >= 1) {
    dt[, CIns_ratio_T2 := rowSums(.SD, na.rm = TRUE) / inscritsT2, .SDcols = T2candidateC]
    dt[is.infinite(CIns_ratio_T2), CIns_ratio_T2 := 1]
    } 
  else {dt[, CIns_ratio_T2 := NA]}
  if (length(T2candidateE) >= 1) {
    dt[, EIns_ratio_T2 := rowSums(.SD, na.rm = TRUE) / inscritsT2, .SDcols = T2candidateE]
    dt[is.infinite(EIns_ratio_T2), EIns_ratio_T2 := 1]
    } 
  else {dt[, EIns_ratio_T2 := NA]}

# Régresseurs
## Propriétaires  
  var_name_1 <- paste0("ppropri", input_year)
  dt[propri, "ppropri" := .(get(var_name_1)), on = "codecommune"]
## Population
  var_name_1 <- paste0("pop", input_year)
  var_name_2 <- paste0("popagglo", input_year)
  dt[popul, c("popcomm", "popagglo") := .(get(var_name_1), get(var_name_2)), on = "codecommune"]
## Âge et sexe
  suffixes <- c("age", "prop014", "prop1539", "prop4059", "prop60p", "propf")
  for (suffix in suffixes) {
    var_name <- paste0(suffix, year)
    dt[ages, (suffix) := .(get(var_name)), on = "codecommune"]
  }
## Diplômes
  suffixes <- c("propnodip", "propbac", "propsup")
  for (suffix in suffixes) {
    var_name <- paste0(suffix, year)
    dt[diplo, (suffix) := .(get(var_name)), on = "codecommune"]
  }
## CSP
  suffixes <- c("pagri", "pindp", "pcadr", "ppint", "pempl", "pouvr", "pchom")
  for (suffix in suffixes) {
    var_name <- paste0(suffix, year)
    dt[catsociopro, (suffix) := .(get(var_name)), on = "codecommune"]
  }
## Étrangers
  var_name_1 <- paste0("petranger", input_year)
  dt[nation, "petranger" := .(get(var_name_1)), on = "codecommune"]
## Revenus
## La série commence seulement en 1980
  var_name_1 <- paste0("revmoy", input_year)
  if (var_name_1 %in% colnames(reven))
    {dt[reven, "revmoy" := .(get(var_name_1)), on = "codecommune"]}
  else
    {dt[, "revmoy" := NA]}
## Crimes et délits
## On dispose de données pour 2016, 2018 et 2020.
  if (year == 2017) 
    {dt[crim, "pcrimesdelits" := i.pcrimesdelits2016, on = "codecommune"]}
  else if (year == 2022) 
    {dt[crim, "pcrimesdelits" := i.pcrimesdelits2020, on = "codecommune"]}
  else 
    {dt[, "pcrimesdelits" := NA]}
## RSA
## On dispose de données entre 2017 et 2021.  
  if (year == 2017) 
    {dt[rsa, "prsa" := i.prsa2017, on = "codecommune"]}
  else if (year == 2022) 
    {dt[rsa, "prsa" := i.prsa2021, on = "codecommune"]}
  else 
    {dt[, "prsa" := NA]}
   
# Merge
  cols_to_keep <- intersect(names(full_data), names(dt))
  dt <- dt[, ..cols_to_keep]
  full_data <- rbindlist(list(full_data, dt))
  return(full_data)
}
```

```{r}
# Boucle sur les élections
for (year in unique(candidats$Annee)) {
  output_file <- paste0("pres", year) 
  input_file <- paste0("Elections_pres/pres", year, "comm.parquet")
  assign(output_file, load_parquet(input_file))
  full_data <- recode_merge_pres(year)
  print(year)
}

for (year in 2022) {
  output_file <- paste0("pres", year) 
  input_file <- paste0("Elections_pres/pres", year, "comm.parquet")
  assign(output_file, load_parquet(input_file))
  full_data <- recode_merge_pres(year)
  print(year)
}

write_parquet(full_data, "data_main/full_data.parquet")
```

```{r}
# Nettoyage final
## Suppression des résultats électoraux
for (year in unique(candidats$Annee)) {
  tablename <- paste0("pres", year)
  rm(list = tablename)
}

## Suppression des données de contrôle
rm(ages, candidats, catsociopro, diplo, nation, popul, propri, reven)

## Suppression des variables
rm(i, input_file, output_file, suffixes, tablename, var_name_1, var_name_2, year)
```

**Variables à ajouter**

```{r}
# Taux d'inscription
pres1981[, pinscript := votants/pop1981]
```

```{r}
## Religion
pres1981[religcomm, c("prefract1791", "pclerge1791") :=
             .(i.prefract1791, i.pclerge1791), on = "codecommune"]
pres1981[religdep, c("pclerge1856", "pmessalisants1950") :=
             .(i.pclerge1856, i.pmessalisants1950), on = "dep"]
```

```{r}
# Pour 2017 on a la proportion de foyers soumis à l'ISF et la valeur moyenne du patrimoine / de l'ISF (?) dans Capital_immobilier/isfcommunes.parquet.
mmoyfortune2017
pisf2017
```


**Graphs**

```{r}
# Calculate the average of part_T1 for each year
avg_part_T1 <- aggregate(part_T1 ~ year, data = full_data, FUN = mean)

# Plot the evolution of the average of part_T1 over time
ggplot(avg_part_T1, aes(x = year, y = part_T1)) +
  geom_line() +
  geom_point() +
  labs(x = "Year", y = "Average part_T1", title = "Evolution of Average part_T1 over Time")

```

**Vérifications**

```{r}
print(sum(is.null(full_data$year)))
print(sum(is.na(pres2022$GD_ratio_T1)))
print(sum(is.infinite(pres1981$GD_ratio_T1)))
print(sum(is.infinite(dt$GD_ratio_T1)))
print(sum(!is.na(pres2022$GD_ratio_T1) & !is.finite(pres1981$GD_ratio_T1)))
```

```{r}
column_names <- names(ages)
matching_columns <- grep("1981$", column_names, value = TRUE)
print(matching_columns)

print(ages[, .(propf1981)])
```

