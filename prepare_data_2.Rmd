Travail en cours pour traiter l'ensemble des élections présidentielles.

Procédure :

1.  Créer un df vide avec des colonnes correspondant seulement aux variables électorales désirées - ou aussi aux contrôles ?

2.  Pour chaque fichier électoral...

    1.  Faire les recodages

    2.  Ajouter les contrôles

    3.  Compléter au besoin les recodages

    4.  Traiter les Nan

    5.  Merge avec le df vide

Essayer de prévoir une fonction à chaque fois ?

```{r}
# Chargement des données sur les élections et les orientations politiques
candidats <- fread("data_other/candidats.csv", header = TRUE)

# Chargement et préparation des contrôles
propri <- load_parquet("Proprietaires/proprietairescommunes.parquet")
popul <- load_parquet("Taille_agglo_commune/popcommunes.parquet")
ages <- load_parquet("Age_csp/agesexcommunes.parquet")

diplo <- load_parquet("Diplomes/diplomescommunes.parquet")
## Conversion du nombre de (non-)diplômés en proportion
diplo[popul, c("pop1981") := .(i.pop1981), on = "codecommune"]
diplo[, propnodip1981 := nodip1981/pop1981]
diplo[, propbac1981 := bac1981/pop1981]
diplo[, propsup1981 := sup1981/pop1981]

religcomm <- load_parquet("Enseignement_prive/religiositecommunes.parquet")
religdep <- load_parquet("Enseignement_prive/religiositedepartements.parquet")
## Ratio de nclerge1791 sur le nombre d'habitants, pour avoir une idée de la présence des institutions religieuses dans la commune.
religcomm[popul, c("pop1791") := .(i.pop1791), on = "codecommune"]
religcomm[, pclerge1791 := nclerge1791/pop1791]
religcomm[, pclerge1791 := replace(pclerge1791, is.infinite(pclerge1791), NA)]

catsociopro <- load_parquet("CSP/cspcommunes.parquet")
nation <- load_parquet("Nationalites/etrangerscommunes.parquet")
reven <- load_parquet("Revenus/revcommunes.parquet")
```

```{r}
# Création de la base finale
full_data <- data.table(
  dep = character(),
  codecommune = character(),
  year = integer(),
  inscrits = numeric(), 
  # on l'utilisera après fusion avec la population pour calculer le taux d'inscrits
  # si cette information n'est pas déjà estimée par les auteurs
  part_T1 = numeric(),
  part_T2 = numeric(),
  GD_ratio_T1 = numeric(),
  GD_ratio_T2 = numeric(),
  ppropri = numeric()
  )
```

```{r}
# Recodages politiques + tentative de merge
recode_merge_pres <- function(input_year) {
  tablename <- paste0("pres", input_year)
  dt <- get(tablename)
 #  Ajout des années lorsqu'elles manquent
  if (year %in% colnames(dt)) {
    dt[is.na(dt$year), year := input_year]
    } else {
      dt[, year := input_year]}
 # Participation
  dt[, part_T1 := votants/inscrits]
  dt[, part_T2 := votantsT2/inscritsT2]
 # Droite / gauche
  T1mask <- candidats[Annee == input_year & DrGau == "G", .(variable = paste0("voix", Candidat))]
  dt[, GD_ratio_T1 := rowSums(.SD, na.rm = TRUE) / exprimes, .SDcols = T1mask$variable]
  dt[is.infinite(GD_ratio_T1), GD_ratio_T1 := 1]
  T2mask <- candidats[Annee == input_year & DrGau == "G", .(variable = paste0("voixT2", Candidat))]
  T2candidate <- intersect(T2mask$variable, names(dt))
  dt[, GD_ratio_T2 := rowSums(.SD, na.rm = TRUE) / exprimesT2, .SDcols = T2candidate]
  dt[is.infinite(GD_ratio_T2), GD_ratio_T2 := 1]
# Contrôles
  var_name_1 <- paste0("ppropri", input_year)
  dt[propri, c("ppropri") := .(i.var_name_1), on = "codecommune"]
  var_name_1 <- paste0("pop", input_year)
  var_name_2 <- paste0("popagglo", input_year)
  print(var_name_1)
  print(var_name_2)
  dt[popul, c("popcomm", "popagglo") := .(get(var_name_1), get(var_name_2)), on = "codecommune"]
# Merge
  cols_to_keep <- intersect(names(full_data), names(dt))
  dt <- dt[, ..cols_to_keep]
  full_data <- rbindlist(list(full_data, dt))
  return(full_data)
}
```

recode_merge_pres <- function(input_year) {
  tablename <- paste0("pres", input_year)
  dt <- get(tablename)
  var_name_1 <- paste0("ppropri", input_year)
  dt[propri, c("ppropri") := .(i.var_name_1), on = "codecommune"]
  var_name_1 <- paste0("pop", input_year)
  var_name_2 <- paste0("popagglo", input_year)
  dt[popul, c("popcomm", "popagglo") := .(i.var_name_1, i.var_name_2), on = "codecommune"]
  return(dt)
}

```{r}
# Ajout des contrôles


# Code pour 1981 seulement, à convertir en fonction
pres1981[ages, c("age1981", "prop0141981", "prop15391981", "prop40591981", "prop60p1981") :=
             .(i.age1981, i.prop0141981, i.prop15391981, i.prop40591981, i.prop60p1981), on = "codecommune"]
pres1981[diplo, c("propnodip1981", "propbac1981", "propsup1981") :=
             .(i.propnodip1981, i.propbac1981, propsup1981), on = "codecommune"]
pres1981[religcomm, c("prefract1791", "pclerge1791") :=
             .(i.prefract1791, i.pclerge1791), on = "codecommune"]
pres1981[religdep, c("pclerge1856", "pmessalisants1950") :=
             .(i.pclerge1856, i.pmessalisants1950), on = "dep"]
pres1981[catsociopro, c("pagri1981", "pindp1981", "pcadr1981", "ppint1981", "pempl1981", "pouvr1981", "pchom1981") :=
             .(i.pagri1981, i.pindp1981, i.pcadr1981, i.ppint1981, i.pempl1981, i.pouvr1981, i.pchom1981), on = "codecommune"]
pres1981[nation, c("petranger1981") :=
             .(i.petranger1981), on = "codecommune"]
pres1981[reven, c("revmoy1981") :=
             .(i.revmoy1981), on = "codecommune"]
```

```{r}
# Boucle sur les élections
for (year in unique(candidats$Annee)) {
  output_file <- paste0("pres", year) 
  input_file <- paste0("Elections_pres/pres", year, "comm.parquet")
  assign(output_file, load_parquet(input_file))
  full_data <- recode_merge_pres(year)
  # faudra modifier au-dessus, que la fonction ne sorte pas full_data mais pres<year>
  # full_data <- add_controls(year)
  
}
```

```{r}
# Nettoyage final
rm(recode_merge_pres)
## Suppression des résultats électoraux
for (year in unique(candidats$Annee)) {
  tablename <- paste0("pres", year)
  rm(list = tablename)
}
## Suppression des variables
rm(input_file, output_file)
```

Pour la population
Supprimer : "nomdep" "nomcommune" "nomreg" "paris" ? "codeagglo" ? "nomagglo" ? "multicommune" ? après suivent popagglo et popcommune pour toutes les années depuis 1780.

```{r}
full_data <- load_parquet("Taille_agglo_commune/popcommunes.parquet")

print(unique(dt$full_data))

# Taux d'inscription
pres1981[, pinscript := votants/pop1981]
# Mais on ne l'a pas encore...
# Commencer par récupérer la population ?
# On peut aussi utiliser les estimations du nombre d'électeurs par C&P
```

```{r}
# Calculate the average of part_T1 for each year
avg_part_T1 <- aggregate(part_T1 ~ year, data = full_data, FUN = mean)

# Plot the evolution of the average of part_T1 over time
ggplot(avg_part_T1, aes(x = year, y = part_T1)) +
  geom_line() +
  geom_point() +
  labs(x = "Year", y = "Average part_T1", title = "Evolution of Average part_T1 over Time")

```


```{r}
print(sum(is.null(full_data$year)))
print(sum(is.na(pres2022$GD_ratio_T1)))
print(sum(is.infinite(pres1981$GD_ratio_T1)))
print(sum(is.infinite(dt$GD_ratio_T1)))
print(sum(!is.na(pres2022$GD_ratio_T1) & !is.finite(pres1981$GD_ratio_T1)))

## Libéralisme culturel / conservatisme moral
T1mask <- candidats[LibCons == "L", .(variable = paste0("voix", Candidat))]
pres1981[, lib_ratio_T1 := rowSums(.SD, na.rm = TRUE) / exprimes, .SDcols = T1mask$variable]

# Nettoyage
prefixes_to_drop <- c("exprimes", "inscrits", "nom", "nul", "pervote", "ppar", "pvoix", "pvote", "voix", "vot")
pres1981 <- pres1981[, .SD, .SDcols = setdiff(names(pres1981), grep(paste0("^", paste(prefixes_to_drop, collapse = "|")), names(pres1981), value = TRUE))]
pres1981 <- pres1981[, -c("plm", "dep2", "plmdoublon", "perpar", "year")]

rm(candidats, T1mask, T2mask, T2candidates, prefixes_to_drop)
```
