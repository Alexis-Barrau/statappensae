Travail en cours pour traiter l'ensemble des élections présidentielles.

On construit la base en itérant à partir des résultats électoraux. On commence par créer une table de destination, intégrant l'ensemble des variables souhaitées. Puis pour chaque fichier électoral...

1.  On recode les outcomes, à l'aide des informations sur les orientations politiques des candidats stockées dans une table dédiée.

2.  On ajoute les contrôles de l'année correspondante.

3.  On fusionne avec la table de destination (rbind pour s'ajouter aux données existantes).

Inconvénient de cette méthode : implique de charger simultanément toutes les bases, donc consomme beaucoup de mémoire (mais passe quand même, sous Win10, avec 16 Go de Ram). Avantage : simplifie beaucoup la sélection des variables pertinentes, et le passage du format wide au format long.

**Données de panel**

```{r}
# Chargement des données sur les orientations politiques des candidats
candidats <- fread("data_other/candidats.csv", header = TRUE)

# Chargement et préparation des régressuers
propri <- load_parquet("Proprietaires/proprietairescommunes.parquet")
popul <- load_parquet("Taille_agglo_commune/popcommunes.parquet")
pop_elec <- load_parquet("Taille_agglo_commune/popcommuneselecteurs.parquet")
ages <- load_parquet("Age_csp/agesexcommunes.parquet")
catsociopro <- load_parquet("CSP/cspcommunes.parquet")
nation <- load_parquet("Nationalites/etrangerscommunes.parquet")
reven <- load_parquet("Revenus/revcommunes.parquet")
diplo <- load_parquet("Diplomes/diplomescommunes.parquet")

## Conversion du nombre de (non-)diplômés en proportion du nombre d'habitants
for (year in unique(candidats$Annee)) {
  suffixes <- c("pop", "propnodip", "propbac", "propsup", "nodip", "bac", "sup")
  for (i in seq_along(suffixes)) {assign(paste0("var_name_", i), paste0(suffixes[i], year))}
  diplo[popul, c(var_name_1) := .(get(var_name_1)), on = "codecommune"]
  diplo[, (var_name_2) := get(var_name_5)/get(var_name_1)]
  diplo[, (var_name_3) := get(var_name_6)/get(var_name_1)]
  diplo[, (var_name_4) := get(var_name_7)/get(var_name_1)]
}
```

```{r}
# Création de la table de destination
panel_data <- data.table(
  dep = character(),
  codecommune = character(),
  year = integer(),
  # inscrits = numeric(), 
  # on l'utilisera après fusion avec la population pour calculer le taux d'inscrits
  # si cette information n'est pas déjà estimée par les auteurs
  part_T1 = numeric(),
  part_T2 = numeric(),
  GD_ratio_T1 = numeric(),
  GD_ratio_T2 = numeric(),
  GIns_ratio_T1 = numeric(),
  DIns_ratio_T1 = numeric(),
  GIns_ratio_T2 = numeric(),
  DIns_ratio_T2 = numeric(),
  EC_ratio_T1 = numeric(),
  EC_ratio_T2 = numeric(),
  EIns_ratio_T1 = numeric(),
  CIns_ratio_T1 = numeric(),
  EIns_ratio_T2 = numeric(),
  CIns_ratio_T2 = numeric(),  
  ppropri = numeric(),
  popcomm = numeric(),
  popagglo = numeric (),
  pinscript = numeric (),
  age = numeric (),
  prop014 = numeric (),
  prop1539 = numeric (),
  prop4059 = numeric (),
  prop60p = numeric (),
  propf = numeric(),
  propnodip = numeric (),
  propbac = numeric (),
  propsup = numeric (),
  pagri = numeric (),
  pindp = numeric (),
  pcadr = numeric (),
  ppint = numeric (),
  pempl = numeric (),
  pouvr = numeric (),
  pchom = numeric (),
  petranger = numeric(),
  revmoy = numeric()
  )
```

```{r}
# Fonction assurant le recodage des outcomes, l'ajout des régresseurs et la fusion avec la base de destination
recode_add_bind <- function(input_year) {
  tablename <- paste0("pres", input_year)
  dt <- get(tablename)
# Ajout des années lorsqu'elles manquent dans la table d'origine
  if (year %in% colnames(dt)) {dt[is.na(dt$year), year := input_year]}
  else {dt[, year := input_year]}

# Outcomes
## Participation
  dt[, part_T1 := votants/inscrits]
  dt[, part_T2 := votantsT2/inscritsT2]
## Droite / gauche
### Identification des candidats
  T1maskG <- candidats[Annee == input_year & DrGau == "G", .(variable = paste0("voix", Candidat))]
  T1maskD <- candidats[Annee == input_year & DrGau == "D", .(variable = paste0("voix", Candidat))]
  T2maskG <- candidats[Annee == input_year & DrGau == "G", .(variable = paste0("voixT2", Candidat))]
  T2candidateG <- intersect(T2maskG$variable, names(dt))
  T2maskD <- candidats[Annee == input_year & DrGau == "D", .(variable = paste0("voixT2", Candidat))]
  T2candidateD <- intersect(T2maskD$variable, names(dt))
### Ratio relatif / sur l'orientation politique opposée
  dt[, GD_ratio_T1 := rowSums(.SD, na.rm = TRUE) / exprimes, .SDcols = T1maskG$variable]
  dt[is.infinite(GD_ratio_T1), GD_ratio_T1 := 1]
  # Pour le second tour, le ratio G/exp est seulement calculé si un candidat de gauche est présent.
  if (length(T2candidateG) == 1) {
    dt[, GD_ratio_T2 := rowSums(.SD, na.rm = TRUE) / exprimesT2, .SDcols = T2candidateG]
    dt[is.infinite(GD_ratio_T2), GD_ratio_T2 := 1]
    }
  else {dt[, GD_ratio_T2 := NA]}
### Ratios absolus / sur les inscrits
  dt[, GIns_ratio_T1 := rowSums(.SD, na.rm = TRUE) / inscrits, .SDcols = T1maskG$variable]
  dt[is.infinite(GIns_ratio_T1), GIns_ratio_T1 := 1]
  dt[, DIns_ratio_T1 := rowSums(.SD, na.rm = TRUE) / inscrits, .SDcols = T1maskD$variable]
  dt[is.infinite(DIns_ratio_T1), DIns_ratio_T1 := 1]
  # Pour le second tour, le ratio de chaque orientation est seulement calculé si un candidat est présent. 
  if (length(T2candidateG) >= 1) {
    dt[, GIns_ratio_T2 := rowSums(.SD, na.rm = TRUE) / inscritsT2, .SDcols = T2candidateG]
    dt[is.infinite(GIns_ratio_T2), GIns_ratio_T2 := 1]
    } 
  else {dt[, GIns_ratio_T2 := NA]}
  if (length(T2candidateD) >= 1) {
    dt[, DIns_ratio_T2 := rowSums(.SD, na.rm = TRUE) / inscritsT2, .SDcols = T2candidateD]
    dt[is.infinite(DIns_ratio_T2), DIns_ratio_T2 := 1]
    } 
  else {dt[, DIns_ratio_T2 := NA]}
## Centre / extrêmes
### Identification des candidats
  T1maskC <- candidats[Annee == input_year & CentExt == "C", .(variable = paste0("voix", Candidat))]
  T1maskE <- candidats[Annee == input_year & CentExt == "E", .(variable = paste0("voix", Candidat))]
  T2maskC <- candidats[Annee == input_year & CentExt == "C", .(variable = paste0("voixT2", Candidat))]
  T2candidateC <- intersect(T2maskC$variable, names(dt))
  T2maskE <- candidats[Annee == input_year & CentExt == "E", .(variable = paste0("voixT2", Candidat))]
  T2candidateE <- intersect(T2maskE$variable, names(dt))
### Ratio relatif / sur l'orientation politique opposée
  dt[, EC_ratio_T1 := rowSums(.SD, na.rm = TRUE) / exprimes, .SDcols = T1maskE$variable]
  dt[is.infinite(EC_ratio_T1), EC_ratio_T1 := 1]
  # Pour le second tour, le ratio E/exp est seulement calculé si un candidat des extrêmes est présent.
  if (length(T2candidateE) == 1) {
    dt[, EC_ratio_T2 := rowSums(.SD, na.rm = TRUE) / exprimesT2, .SDcols = T2candidateE]
    dt[is.infinite(EC_ratio_T2), EC_ratio_T2 := 1]
    }
  else {dt[, EC_ratio_T2 := NA]}
### Ratios absolus / sur les inscrits
  dt[, CIns_ratio_T1 := rowSums(.SD, na.rm = TRUE) / inscrits, .SDcols = T1maskC$variable]
  dt[is.infinite(CIns_ratio_T1), CIns_ratio_T1 := 1]
  dt[, EIns_ratio_T1 := rowSums(.SD, na.rm = TRUE) / inscrits, .SDcols = T1maskE$variable]
  dt[is.infinite(EIns_ratio_T1), EIns_ratio_T1 := 1]
  # Pour le second tour, le ratio de chaque orientation est seulement calculé si un candidat est présent. 
  if (length(T2candidateC) >= 1) {
    dt[, CIns_ratio_T2 := rowSums(.SD, na.rm = TRUE) / inscritsT2, .SDcols = T2candidateC]
    dt[is.infinite(CIns_ratio_T2), CIns_ratio_T2 := 1]
    } 
  else {dt[, CIns_ratio_T2 := NA]}
  if (length(T2candidateE) >= 1) {
    dt[, EIns_ratio_T2 := rowSums(.SD, na.rm = TRUE) / inscritsT2, .SDcols = T2candidateE]
    dt[is.infinite(EIns_ratio_T2), EIns_ratio_T2 := 1]
    } 
  else {dt[, EIns_ratio_T2 := NA]}

# Régresseurs
## Propriétaires
  var_name_1 <- paste0("ppropri", input_year)
  dt[propri, "ppropri" := .(get(var_name_1)), on = "codecommune"]
## Population
  var_name_1 <- paste0("pop", input_year)
  var_name_2 <- paste0("popagglo", input_year)
  dt[popul, c("popcomm", "popagglo") := .(get(var_name_1), get(var_name_2)), on = "codecommune"]
## Taux d'inscription sur les listes électorales
  var_name_1 <- paste0("electeurs", input_year)
  dt[pop_elec, "nb_electeurs" := .(get(var_name_1)), on = "codecommune"]
  dt[, "pinscript" := inscrits / nb_electeurs]
  dt[is.infinite(pinscript), pinscript := NA]
  dt[, nb_electeurs := NULL]
## Âge et sexe
  suffixes <- c("age", "prop014", "prop1539", "prop4059", "prop60p", "propf")
  for (suffix in suffixes) {
    var_name <- paste0(suffix, year)
    dt[ages, (suffix) := .(get(var_name)), on = "codecommune"]
  }
## Diplômes
  suffixes <- c("propnodip", "propbac", "propsup")
  for (suffix in suffixes) {
    var_name <- paste0(suffix, year)
    dt[diplo, (suffix) := .(get(var_name)), on = "codecommune"]
  }
## CSP
  suffixes <- c("pagri", "pindp", "pcadr", "ppint", "pempl", "pouvr", "pchom")
  for (suffix in suffixes) {
    var_name <- paste0(suffix, year)
    dt[catsociopro, (suffix) := .(get(var_name)), on = "codecommune"]
  }
## Étrangers
  var_name_1 <- paste0("petranger", input_year)
  dt[nation, "petranger" := .(get(var_name_1)), on = "codecommune"]
## Revenus
## La série commence en 1980.
  var_name_1 <- paste0("revmoy", input_year)
  if (var_name_1 %in% colnames(reven))
    {dt[reven, "revmoy" := .(get(var_name_1)), on = "codecommune"]}
  else
    {dt[, "revmoy" := NA]}

# Bind
  cols_to_keep <- intersect(names(panel_data), names(dt))
  dt <- dt[, ..cols_to_keep]
  panel_data <- rbindlist(list(panel_data, dt))
  return(panel_data)
}
```

```{r}
# Boucle sur les élections pour constituer les données de panel
for (year in unique(candidats$Annee)) {
  output_file <- paste0("pres", year) 
  input_file <- paste0("Elections_pres/pres", year, "comm.parquet")
  assign(output_file, load_parquet(input_file))
  panel_data <- recode_add_bind(year)
  cat("Data generated for year", year, "\n")
}

write_parquet(panel_data, "data_main/panel_data.parquet")
```

```{r}
# Nettoyage
## Suppression des résultats électoraux
for (year in unique(candidats$Annee)) {
  tablename <- paste0("pres", year)
  rm(list = tablename)
}

## Suppression des données de contrôle
rm(ages, candidats, catsociopro, diplo, nation, pop_elec, popul, propri, reven)

## Suppression des variables
for (name in paste0("var_name_", 1:7)) {rm(list = name)}
rm(i, input_file, name, tablename, output_file, suffixes, year)
```

```{r eval=FALSE}
# Téléversement sur le SSP Cloud
aws.s3::put_object(
  "data_main/panel_data.parquet",
  object = "/diffusion/panel_data.parquet",
  bucket = "maeldieudonne",
  region = "",
  multipart = TRUE
)
```

**Données pour l'ACP**

Pour ajouter les régresseurs seulement disponibles en fin de période.

```{r}
# Chargement des bases
crim <- load_parquet("CSP/crimesdelitscommunes.parquet")
isf <- load_parquet("Capital_immobilier/isfcommunes.parquet")
rsa <- load_parquet("CSP/rsacommunes.parquet")
vbbm <- load_parquet("Taille_agglo_commune/popcommunesvbbm.parquet")

## Correction des codes communes dans la base RSA (traités comme des nombres donc avec suppression des zéros initiaux)
rsa$codecommune <- as.character(rsa$codecommune)
rsa$codecommune <- ifelse(nchar(rsa$dep) == 1, paste0("0", rsa$codecommune), rsa$codecommune)

# Sélection de l'année 2017 dans les données de panel et ajout de régresseurs supplémentaires
acp_data <- subset(panel_data, year == 2017)
acp_data[crim, "pcrimesdelits" := i.pcrimesdelits2016, on = "codecommune"]
acp_data[isf, c("mmoyfortune", "pisf") := .(mmoyfortune2017, pisf2017), on = "codecommune"]
acp_data[rsa, "prsa" := i.prsa2017, on = "codecommune"]
acp_data[vbbm, "type_comm" := i.vbbm2017, on = "codecommune"]

## Les données fiscales sont disponibles uniquement pour les communes de plus de 20 000 habitants comptant au moins 50 contribuables assujettis à l'ISF (soit 374 communes rassemblant 22,3 millions d’habitants en 2017).
## Les valeurs manquantes sont remplacées par des valeurs nulles.
acp_data[is.na(mmoyfortune), mmoyfortune := 0]
acp_data[is.na(pisf), pisf := 0]

# Ecriture du fichier et nettoyage
write_parquet(acp_data, "data_main/acp_data.parquet")
rm(crim, isf, rsa, vbbm)
```

```{r}
# Ajout éventuel : les indicateurs de religiosité (dont l'inconvénient est d'être anciens et d'avoir beaucoup de valeurs manquantes)

## Chargement des bases
religcomm <- load_parquet("Enseignement_prive/religiositecommunes.parquet")
religdep <- load_parquet("Enseignement_prive/religiositedepartements.parquet")
popul <- load_parquet("Taille_agglo_commune/popcommunes.parquet")

## Ratio de nclerge1791 sur le nombre d'habitants, pour avoir une idée de la présence des institutions religieuses dans la commune
religcomm[popul, c("pop1791") := .(i.pop1791), on = "codecommune"]
religcomm[, pclerge1791 := nclerge1791/pop1791]
religcomm[, pclerge1791 := replace(pclerge1791, is.infinite(pclerge1791), NA)]

## Ajout aux données
acp_data[religcomm, c("prefract1791", "pclerge1791") :=
             .(i.prefract1791, i.pclerge1791), on = "codecommune"]
acp_data[religdep, c("pclerge1856", "pmessalisants1950") :=
             .(i.pclerge1856, i.pmessalisants1950), on = "dep"]

## Ecriture du fichier et nettoyage
write_parquet(acp_data, "data_main/acp_data.parquet")
rm(popul, religcomm, religdep)
```

```{r eval=FALSE}
# Téléversement sur le SSP Cloud
aws.s3::s3write_using(
  acp_data
  FUN = arrow::write_parquet,
  object = "/diffusion/acp.parquet",
  bucket = "maeldieudonne",
  opts = list("region" = "")
)
```

**Cartes**

Fonction qui fusionne les données avec les contours des communes pour permettre de tracer des cartes.

Données très volumineuses car très précises, et identiques pour toutes les années dans la base.

Donc au lieu de les ajouter de manière redondante aux bases précédentes, on créé une fonction pour générer à la demande la table nécessaire.

Difficulté : données pour Paris sont présentées à l'échelle des arrondissements. Donc faut utiliser une seconde base géographique.

On ajoute aussi les codes régionaux de l'Insee pour permettre de tracer des cartes à l'échelle régionale (la plus lisible).

```{r}
codes_regions <- fread("data_other/codes_regions_Insee.csv", header = TRUE)
codes_regions$ABRV <- sapply(codes_regions$LIBELLE, get_first_letters)

create_map_data <- function(input_year) {
  dt <- subset(panel_data, year == input_year)
  
  # Contours des départements
  background_province <- load_shapefile("COMMUNE.shx")
  map_data_province <- merge(background_province, subset(dt, dep != 75), by.x = "INSEE_COM", by.y = "codecommune", all.x = TRUE)
  map_data_province <- subset(map_data_province, select = -c(INSEE_ARR, INSEE_CAN, INSEE_DEP, SIREN_EPCI, STATUT))
  
  # Contour des arrondissements
  background_plm <- load_shapefile("ARRONDISSEMENT_MUNICIPAL.shx")
  ## Ajout du code région
  background_plm$INSEE_REG <- ifelse(startsWith(background_plm$INSEE_COM, "13"), 93,
                                    ifelse(startsWith(background_plm$INSEE_COM, "69"), 84,
                                           ifelse(startsWith(background_plm$INSEE_COM, "75"), 11, NA)))

  # Fusion pour les arrondissements parisiens
  map_data_paris <- merge(background_plm, subset(dt, dep == 75), by.x = "INSEE_ARM", by.y = "codecommune", all.x = TRUE)
  map_data_paris <- subset(map_data_paris, select = -INSEE_ARM)
  
  # Fusion globale
  map_data <- rbind(map_data_province, map_data_paris)
  st_crs(map_data) <- 9794

  return(map_data)
}
```
