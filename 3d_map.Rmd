
```{r}
install.packages("devtools")
devtools::install_github("tylermorganwall/rayshader")

packages <- c(
  "doParallel",
  "foreach",
  "Rcpp",
  "progress",
  "raster",
  "scales",
  "png",
  "magrittr",
  "terrainmeshr",
  "rayimage",
  "rayvertex",
  "rayrender",
  "rayshader",
  "rgl",
  "fasterize")

installed_packages <- packages %in% rownames(installed.packages())
if (any(installed_packages == FALSE)) {
  install.packages(packages[!installed_packages])
}

invisible(lapply(packages, library, character.only = TRUE))

rm(installed_packages, packages)
```

```{r}
# Fonctionne seulement en local, pas depuis le datalab
# Pas trouvé de solution pour avoir une légende pour chaque variable
selected_dep <- "26"
subset_map_data <- map_data[map_data$dep == selected_dep, ]

ggVktor <- ggplot(data=subset_map_data) +
  geom_sf(aes(fill = part, height = ppropri1981)) +
  scale_fill_viridis() +
  ggtitle("Participation et taux de propriété dans la Drôme") +
  theme_bw() +
  guides(
    fill = guide_colourbar(title = "Participation"),
    height = guide_legend(title = "Taux de propriétaires")
  )

plot_gg(
  ggVktor,
  multicore = TRUE, 
  shadow = FALSE,
  width = 8, 
  height = 8, 
  scale = 200,
  windowsize=c(1680,1050), 
  zoom = 0.60, 
  phi = 50,
  sunangle = 120,
  theta = 45)

render_snapshot()
```




```{r}
df <- load_shapefile("ARRONDISSEMENT_MUNICIPAL.shx")

df_sf <- st_as_sf(df, wkt = "geometry")
# Create an empty raster with desired resolution and extent
r <- raster(extent(df_sf), resolution = c(50, 50))  # Adjust resolution as needed
rasterized <- rasterize(df_sf, r)

raster_points <- raster::rasterToPoints(rasterized)

# Extract values and coordinates
values <- raster_points[,3]
coordinates <- raster_points[,1:2]

# Get the number of rows and columns in the raster
nrows <- nrow(rasterized)
ncols <- ncol(rasterized)

# Create an empty matrix
matrix_data <- matrix(NA, nrow = nrows, ncol = ncols)

# Fill the matrix with raster values
for (i in 1:length(values)) {
  row_index <- as.integer((coordinates[i, 2] - extent(rasterized)[2]) / res(rasterized)[2]) + 1
  col_index <- as.integer((coordinates[i, 1] - extent(rasterized)[1]) / res(rasterized)[1]) + 1
  if (row_index > 0 && row_index <= nrows && col_index > 0 && col_index <= ncols) {
    matrix_data[row_index, col_index] <- values[i]
  }
}
```

```{r}
create_raster_data

create_map_data <- function(input_year) {
  dt <- subset(panel_data, year == input_year)
  
  # Contours des départements
  background_province <- load_shapefile("COMMUNE.shx")
  map_data_province <- merge(background_province, subset(dt, dep != 75), by.x = "INSEE_COM", by.y = "codecommune", all.x = TRUE)
  map_data_province <- subset(map_data_province, select = -c(INSEE_ARR, INSEE_CAN, INSEE_DEP, SIREN_EPCI, STATUT))
  
  # Contour des arrondissements
  background_plm <- load_shapefile("ARRONDISSEMENT_MUNICIPAL.shx")
  ## Ajout du code région
  background_plm$INSEE_REG <- ifelse(startsWith(background_plm$INSEE_COM, "13"), 93,
                                    ifelse(startsWith(background_plm$INSEE_COM, "69"), 84,
                                           ifelse(startsWith(background_plm$INSEE_COM, "75"), 11, NA)))

  # Fusion pour les arrondissements parisiens
  map_data_paris <- merge(background_plm, subset(dt, dep == 75), by.x = "INSEE_ARM", by.y = "codecommune", all.x = TRUE)
  map_data_paris <- subset(map_data_paris, select = -INSEE_ARM)
  
  # Fusion globale
  map_data <- rbind(map_data_province, map_data_paris)
  st_crs(map_data) <- 9794

  return(map_data)
}
```

